<!doctype html><html lang=zh-CN data-theme=dark><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.126.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon_me.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon_me.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16.ico><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32.ico><link rel=apple-touch-icon sizes=180x180 href><meta itemprop=name content="深入了解LinkedHashMap"><meta itemprop=description content><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="//localhost:1313/imgs/me.jpg"><meta itemprop=keywords content><meta property="og:type" content="article"><meta property="og:title" content="深入了解LinkedHashMap"><meta property="og:description" content><meta property="og:image" content="/imgs/me.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="//localhost:1313/post/java-base/linkedhashmap/"><meta property="og:site_name" content="shuyou"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="shuyou"><meta property="article:published_time" content="2021-03-16 00:00:00 +0000 UTC"><meta property="article:modified_time" content="2024-06-09 00:00:00 +0000 UTC"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.css><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":true,"isHome":false,"isPage":true,"path":"linkedhashmap","permalink":"//localhost:1313/post/java-base/linkedhashmap/","title":"深入了解LinkedHashMap","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>深入了解LinkedHashMap - shuyou</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>shuyou</h1><i class=logo-line></i></a></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>63</span></a></li><li class="menu-item menu-item-categories"><a href=/categories/ class=hvr-icon-pulse rel=section><i class="fa fa-folder hvr-icon"></i>标签</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><ul><li><a href=#简介>简介</a></li><li><a href=#构造函数>构造函数</a></li><li><a href=#数据结构>数据结构</a></li><li><a href=#增>增</a></li><li><a href=#删>删</a></li><li><a href=#改>改</a></li><li><a href=#查>查</a></li><li><a href=#containsvalue>containsValue</a></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=shuyou src=/imgs/img-lazy-loading.gif data-src=/imgs/me.jpg><p class=site-author-name itemprop=name>shuyou</p><div class=site-description itemprop=description></div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>63</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>16</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>0</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/ZouShuYou title="Github → https://github.com/ZouShuYou" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate=2022-01-06T00:00:00+00:00></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=95151></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=222></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate=2020-11-29T00:00:00+00:00></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><a href=https://github.com/hugo-next rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg>
</a><script type=text/javascript src=//sidecar.gitter.im/dist/sidecar.v1.js async></script><script type=text/javascript>((window.gitter={}).chat={}).options={room:"hugo-next/community"}</script><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=//localhost:1313/post/java-base/linkedhashmap/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/me.jpg"><meta itemprop=name content="shuyou"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="shuyou"><meta itemprop=description content></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="深入了解LinkedHashMap"><meta itemprop=description content="本文介绍LinkedHashMap的相关知识 简介 之前了解过HashMap，HashMap是无序的，当我们希望有顺序地去存储key-value"></span><header class=post-header><h1 class=post-title itemprop="name headline">深入了解LinkedHashMap
<a href=https://github.com/ZouShuYou/ZouShuYou.github.io/tree/master/content/post/Java%20Base/LinkedHashMap.md rel="noopener external nofollow noreferrer" target=_blank class="exturl post-edit-link" title=编辑><i class="fa fa-pen-nib"></i></a></h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2021-03-16 00:00:00 +0000 UTC" itemprop="dateCreated datePublished" datetime="2021-03-16 00:00:00 +0000 UTC">2021-03-16
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i>
</span><span class=post-meta-item-text title=更新于>更新于：
</span><time title=修改时间：2024-06-09T00:00:00+00:00 itemprop=dateModified datetime=2024-06-09T00:00:00+00:00>2024-06-09</time>
</span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/java%E9%9B%86%E5%90%88 itemprop=url rel=index><span itemprop=name>Java集合</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>2790</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>6分钟</span>
</span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="far fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=busuanzi_value_page_pv data-path=/post/java-base/linkedhashmap/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><blockquote><p>本文介绍LinkedHashMap的相关知识</p></blockquote><h3 id=简介>简介
<a class=header-anchor href=#%e7%ae%80%e4%bb%8b></a></h3><p>之前了解过HashMap，HashMap是无序的，当我们希望有顺序地去存储key-value时，就需要使用LinkedHashMap了。</p><p>LinkedHashMap由哈希表+双向链表组成，它继承自HashMap，重写了HashMap的一些方法，可以用于LRU算法，它和HashMap一样不是线程安全的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TestLinkedHashMap</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        LinkedHashMap<span style=color:#f92672>&lt;</span>String, String<span style=color:#f92672>&gt;</span> linkedHashMap <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LinkedHashMap<span style=color:#f92672>&lt;</span>String, String<span style=color:#f92672>&gt;</span>(16,0.<span style=color:#a6e22e>75f</span>,<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>        linkedHashMap.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;name1&#34;</span>, <span style=color:#e6db74>&#34;josan1&#34;</span>);
</span></span><span style=display:flex><span>        linkedHashMap.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;name2&#34;</span>, <span style=color:#e6db74>&#34;josan2&#34;</span>);
</span></span><span style=display:flex><span>        linkedHashMap.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;name3&#34;</span>, <span style=color:#e6db74>&#34;josan3&#34;</span>);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;LinkedHashMap遍历时顺序：&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (Entry<span style=color:#f92672>&lt;</span>String, String<span style=color:#f92672>&gt;</span> entry : linkedHashMap.<span style=color:#a6e22e>entrySet</span>()){
</span></span><span style=display:flex><span>            String key <span style=color:#f92672>=</span> (String) entry.<span style=color:#a6e22e>getKey</span>();
</span></span><span style=display:flex><span>            String value <span style=color:#f92672>=</span> (String) entry.<span style=color:#a6e22e>getValue</span>();
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;key:&#34;</span> <span style=color:#f92672>+</span> key <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;,value:&#34;</span> <span style=color:#f92672>+</span> value);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        HashMap<span style=color:#f92672>&lt;</span>String, String<span style=color:#f92672>&gt;</span> hashMap <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;</span>String, String<span style=color:#f92672>&gt;</span>(16);
</span></span><span style=display:flex><span>        hashMap.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;name1&#34;</span>, <span style=color:#e6db74>&#34;josan1&#34;</span>);
</span></span><span style=display:flex><span>        hashMap.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;name2&#34;</span>, <span style=color:#e6db74>&#34;josan2&#34;</span>);
</span></span><span style=display:flex><span>        hashMap.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;name3&#34;</span>, <span style=color:#e6db74>&#34;josan3&#34;</span>);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;HashMap遍历时顺序：&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (Entry<span style=color:#f92672>&lt;</span>String, String<span style=color:#f92672>&gt;</span> entry : hashMap.<span style=color:#a6e22e>entrySet</span>()){
</span></span><span style=display:flex><span>            String key <span style=color:#f92672>=</span> (String) entry.<span style=color:#a6e22e>getKey</span>();
</span></span><span style=display:flex><span>            String value <span style=color:#f92672>=</span> (String) entry.<span style=color:#a6e22e>getValue</span>();
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;key:&#34;</span> <span style=color:#f92672>+</span> key <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;,value:&#34;</span> <span style=color:#f92672>+</span> value);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img src=/imgs/img-lazy-loading.gif data-src="https://img-blog.csdnimg.cn/20210316102945365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhcnJvdFpzeQ==,size_16,color_FFFFFF,t_70" alt=在这里插入图片描述>
结果可知，LinkedHashMap是有序的，且默认为插入顺序。</p><h3 id=构造函数>构造函数
<a class=header-anchor href=#%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0></a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LinkedHashMap</span><span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>extends</span> HashMap<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>implements</span> Map<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>LinkedHashMap</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>//accessOrder默认是false，则迭代时输出的顺序是插入节点的顺序。若为true，则输出的顺序是按照访问节点的顺序。</span>
</span></span><span style=display:flex><span>        accessOrder <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>LinkedHashMap</span>(<span style=color:#66d9ef>int</span> initialCapacity) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>(initialCapacity);
</span></span><span style=display:flex><span>        accessOrder <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span> 	<span style=color:#75715e>//指定初始化时的容量，和扩容的加载因子</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>LinkedHashMap</span>(<span style=color:#66d9ef>int</span> initialCapacity, <span style=color:#66d9ef>float</span> loadFactor) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>(initialCapacity, loadFactor);
</span></span><span style=display:flex><span>        accessOrder <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>LinkedHashMap</span>(<span style=color:#66d9ef>int</span> initialCapacity,
</span></span><span style=display:flex><span>                         <span style=color:#66d9ef>float</span> loadFactor,
</span></span><span style=display:flex><span>                         <span style=color:#66d9ef>boolean</span> accessOrder) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>(initialCapacity, loadFactor);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>accessOrder</span> <span style=color:#f92672>=</span> accessOrder;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>LinkedHashMap</span>(Map<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> K, <span style=color:#f92672>?</span> <span style=color:#66d9ef>extends</span> V<span style=color:#f92672>&gt;</span> m) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>();
</span></span><span style=display:flex><span>        accessOrder <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        putMapEntries(m, <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>LinkedHashMap 继承了HashMap，实现了Map接口。</strong></p><p>LinkedHashMap的accessOrder变量默认为false，则迭代时输出的顺序是插入节点的顺序。若为true，则输出的顺序是按照访问节点的顺序。</p><h3 id=数据结构>数据结构
<a class=header-anchor href=#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84></a></h3><p><strong>Entry的next是用于维护HashMap指定table位置上连接的Entry的顺序的，before、After是用于维护Entry插入的先后顺序的。</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span>	<span style=color:#75715e>//LinkedHashMap内部类 Entry继承HashMap的Node内部类，是一个双向链表</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>extends</span> HashMap.<span style=color:#a6e22e>Node</span><span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        Entry<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> before, after;
</span></span><span style=display:flex><span>        Entry(<span style=color:#66d9ef>int</span> hash, K key, V value, Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> next) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>super</span>(hash, key, value, next);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p><img src=/imgs/img-lazy-loading.gif data-src="https://img-blog.csdnimg.cn/20210316104728801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhcnJvdFpzeQ==,size_16,color_FFFFFF,t_70#pic_center" alt=结构图>
<img src=/imgs/img-lazy-loading.gif data-src="https://img-blog.csdnimg.cn/20210316105558286.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhcnJvdFpzeQ==,size_16,color_FFFFFF,t_70#pic_center" alt=在这里插入图片描述>
<strong>该循环双向链表的头部存放的是最久访问的节点或最先插入的节点，尾部为最近访问的或最近插入的节点，迭代器遍历方向是从链表的头部开始到链表尾部结束。</strong></p><h3 id=增>增
<a class=header-anchor href=#%e5%a2%9e></a></h3><p>LinkedHashMap并没有重写任何put方法。但是其重写了构建新节点的newNode()方法.
newNode()会在HashMap的putVal()方法里被调用，putVal()方法会在批量插入数据putMapEntries()或者插入单个数据public V put(K key, V value)时被调用。</p><p>LinkedHashMap重写了newNode()，在每次构建新节点时，通过linkNodeLast，将新节点链接在内部双向链表的尾部。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span>    Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>newNode</span>(<span style=color:#66d9ef>int</span> hash, K key, V value, Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> e) {
</span></span><span style=display:flex><span>        LinkedHashMap.<span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> p <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> LinkedHashMap.<span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span>(hash, key, value, e);
</span></span><span style=display:flex><span>        linkNodeLast(p);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> p;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>linkNodeLast</span>(LinkedHashMap.<span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> p) {
</span></span><span style=display:flex><span>        LinkedHashMap.<span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> last <span style=color:#f92672>=</span> tail;
</span></span><span style=display:flex><span>        <span style=color:#75715e>//tail 指向尾节点即插入的节点</span>
</span></span><span style=display:flex><span>        tail <span style=color:#f92672>=</span> p;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (last <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>            head <span style=color:#f92672>=</span> p;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            p.<span style=color:#a6e22e>before</span> <span style=color:#f92672>=</span> last;
</span></span><span style=display:flex><span>            last.<span style=color:#a6e22e>after</span> <span style=color:#f92672>=</span> p;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p><strong>HashMap专门预留给LinkedHashMap的afterNodeAccess() afterNodeInsertion() afterNodeRemoval() 方法。</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#75715e>// Callbacks to allow LinkedHashMap post-actions</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>afterNodeAccess</span>(Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> p) { }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>afterNodeInsertion</span>(<span style=color:#66d9ef>boolean</span> evict) { }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>afterNodeRemoval</span>(Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> p) { }
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#75715e>//回调函数，新节点插入之后回调 ， 根据evict 和   判断是否需要删除最老插入的节点。如果实现LruCache会用到这个方法。</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>afterNodeInsertion</span>(<span style=color:#66d9ef>boolean</span> evict) { <span style=color:#75715e>// possibly remove eldest</span>
</span></span><span style=display:flex><span>        LinkedHashMap.<span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> first;
</span></span><span style=display:flex><span>        <span style=color:#75715e>//LinkedHashMap 默认返回false 则不删除节点</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (evict <span style=color:#f92672>&amp;&amp;</span> (first <span style=color:#f92672>=</span> head) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> removeEldestEntry(first)) {
</span></span><span style=display:flex><span>            K key <span style=color:#f92672>=</span> first.<span style=color:#a6e22e>key</span>;
</span></span><span style=display:flex><span>            removeNode(hash(key), key, <span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//LinkedHashMap 默认返回false 则不删除节点。 返回true 代表要删除最早的节点。通常构建一个LruCache会在达到Cache的上限是返回true</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>removeEldestEntry</span>(Map.<span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> eldest) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h3 id=删>删
<a class=header-anchor href=#%e5%88%a0></a></h3><p>LinkedHashMap也没有重写remove()方法，因为它的删除逻辑和HashMap并无区别。
但它重写了afterNodeRemoval()这个回调方法。该方法会在Node&lt;K,V> removeNode()方法中回调，removeNode()会在所有涉及到删除节点的方法中被调用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span>	<span style=color:#75715e>//双向链表删除节点</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>afterNodeRemoval</span>(Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> e) { <span style=color:#75715e>// unlink</span>
</span></span><span style=display:flex><span>        LinkedHashMap.<span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> p <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>            (LinkedHashMap.<span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span>)e, b <span style=color:#f92672>=</span> p.<span style=color:#a6e22e>before</span>, a <span style=color:#f92672>=</span> p.<span style=color:#a6e22e>after</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>//要删除的节点p before和after 置空</span>
</span></span><span style=display:flex><span>        p.<span style=color:#a6e22e>before</span> <span style=color:#f92672>=</span> p.<span style=color:#a6e22e>after</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>//p的前置节点为null，则p是头节点，head指向p的后置节点</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (b <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>            head <span style=color:#f92672>=</span> a;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span><span style=color:#75715e>//b不为null，b的后置节点为p的后置节点</span>
</span></span><span style=display:flex><span>            b.<span style=color:#a6e22e>after</span> <span style=color:#f92672>=</span> a;
</span></span><span style=display:flex><span>        <span style=color:#75715e>//p的后置节点为null，则p是尾节点，tail指向p的前置节点</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>            tail <span style=color:#f92672>=</span> b;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span><span style=color:#75715e>//a不为null，a的前置节点为p的前置节点</span>
</span></span><span style=display:flex><span>            a.<span style=color:#a6e22e>before</span> <span style=color:#f92672>=</span> b;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h3 id=改>改
<a class=header-anchor href=#%e6%94%b9></a></h3><p>更改value时，发生hash冲突，逻辑和HashMap的put逻辑一样。</p><h3 id=查>查
<a class=header-anchor href=#%e6%9f%a5></a></h3><p>重写了HashMap的get方法，调用getNode方法，LinkedHashMap只是增加了在成员变量(构造函数时赋值)accessOrder为true的情况下，要去回调void afterNodeAccess()函数，在afterNodeAccess()函数中，会将当前被访问到的节点e，移动至内部的双向链表的尾部。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#66d9ef>public</span> V <span style=color:#a6e22e>get</span>(Object key) {
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> e;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> ((e <span style=color:#f92672>=</span> getNode(hash(key), key)) <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (accessOrder)
</span></span><span style=display:flex><span>            afterNodeAccess(e);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> e.<span style=color:#a6e22e>value</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>afterNodeAccess</span>(Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> e) { <span style=color:#75715e>// move node to last</span>
</span></span><span style=display:flex><span>        LinkedHashMap.<span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> last;<span style=color:#75715e>//原尾节点</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//如果accessOrder 是true ，且原尾节点不等于e</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (accessOrder <span style=color:#f92672>&amp;&amp;</span> (last <span style=color:#f92672>=</span> tail) <span style=color:#f92672>!=</span> e) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>//节点e强转成双向链表节点p</span>
</span></span><span style=display:flex><span>            LinkedHashMap.<span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> p <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>                (LinkedHashMap.<span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span>)e, b <span style=color:#f92672>=</span> p.<span style=color:#a6e22e>before</span>, a <span style=color:#f92672>=</span> p.<span style=color:#a6e22e>after</span>;
</span></span><span style=display:flex><span>            <span style=color:#75715e>//p现在是尾节点， 后置节点一定是null</span>
</span></span><span style=display:flex><span>            p.<span style=color:#a6e22e>after</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            <span style=color:#75715e>//如果p的前置节点是null，则p以前是头结点，所以更新现在的头结点是p的后置节点a</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (b <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                head <span style=color:#f92672>=</span> a;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span><span style=color:#75715e>//否则更新p的前直接点b的后置节点为 a</span>
</span></span><span style=display:flex><span>                b.<span style=color:#a6e22e>after</span> <span style=color:#f92672>=</span> a;
</span></span><span style=display:flex><span>            <span style=color:#75715e>//如果p的后置节点不是null，则更新后置节点a的前置节点为b</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                a.<span style=color:#a6e22e>before</span> <span style=color:#f92672>=</span> b;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span><span style=color:#75715e>//如果原本p的后置节点是null，则p就是尾节点。 此时 更新last的引用为 p的前置节点b</span>
</span></span><span style=display:flex><span>                last <span style=color:#f92672>=</span> b;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (last <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) <span style=color:#75715e>//原本尾节点是null  则，链表中就一个节点</span>
</span></span><span style=display:flex><span>                head <span style=color:#f92672>=</span> p;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> {<span style=color:#75715e>//否则 更新 当前节点p的前置节点为 原尾节点last， last的后置节点是p</span>
</span></span><span style=display:flex><span>                p.<span style=color:#a6e22e>before</span> <span style=color:#f92672>=</span> last;
</span></span><span style=display:flex><span>                last.<span style=color:#a6e22e>after</span> <span style=color:#f92672>=</span> p;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>//尾节点的引用赋值成p</span>
</span></span><span style=display:flex><span>            tail <span style=color:#f92672>=</span> p;
</span></span><span style=display:flex><span>            <span style=color:#75715e>//修改modCount。</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>++</span>modCount;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h3 id=containsvalue>containsValue
<a class=header-anchor href=#containsvalue></a></h3><p>LinkedHashMap重写了该方法，相比HashMap的实现，遍历双向链表更为高效。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>containsValue</span>(Object value) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (LinkedHashMap.<span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> e <span style=color:#f92672>=</span> head; e <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>; e <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>after</span>) {
</span></span><span style=display:flex><span>            V v <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>value</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (v <span style=color:#f92672>==</span> value <span style=color:#f92672>||</span> (value <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> value.<span style=color:#a6e22e>equals</span>(v)))
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>对比HashMap，是用两个for循环遍历，相对低效。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>containsValue</span>(Object value) {
</span></span><span style=display:flex><span>        Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;[]</span> tab; V v;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> ((tab <span style=color:#f92672>=</span> table) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> size <span style=color:#f92672>&gt;</span> 0) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> tab.<span style=color:#a6e22e>length</span>; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (Node<span style=color:#f92672>&lt;</span>K,V<span style=color:#f92672>&gt;</span> e <span style=color:#f92672>=</span> tab<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>; e <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>; e <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>next</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> ((v <span style=color:#f92672>=</span> e.<span style=color:#a6e22e>value</span>) <span style=color:#f92672>==</span> value <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>                        (value <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> value.<span style=color:#a6e22e>equals</span>(v)))
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p><strong>总结</strong></p><ol><li>LinkedHashMap通过继承HashMap重写了它的一些方法，实现了有序性。</li><li>accessOrder ,默认是false，则迭代时输出的顺序是插入节点的顺序。若为true，则输出的顺序是按照访问节点的顺序。为true时，可以在这基础之上构建一个LRUCache。</li><li>LinkedHashMap不是线程安全的，内部结构是哈希表+双向链表。</li><li>LinkedHashMap和HashMap一样，允许一对键值为null，key不能重复，但value可以重复。</li></ol><p><strong>参考</strong></p><ol><li><a href=https://blog.csdn.net/zxt0601/article/details/77429150 title=LinkedHashMap源码解析（JDK8） rel="noopener external nofollow noreferrer" target=_blank class=exturl>LinkedHashMap源码解析（JDK8）
<i class="fa fa-external-link-alt"></i></a></li><li><a href=https://www.jianshu.com/p/8f4f58b4b8ab title=图解LinkedHashMap原理 rel="noopener external nofollow noreferrer" target=_blank class=exturl>图解LinkedHashMap原理
<i class="fa fa-external-link-alt"></i></a></li><li><a href=https://www.cnblogs.com/xiaoxi/p/6170590.html title=Java集合之LinkedHashMap rel="noopener external nofollow noreferrer" target=_blank class=exturl>Java集合之LinkedHashMap
<i class="fa fa-external-link-alt"></i></a></li></ol></div><footer class=post-footer><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right alt=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
深入了解LinkedHashMap</li><li class=post-copyright-author><strong>本文作者： </strong>shuyou</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=//localhost:1313/post/java-base/linkedhashmap/ title=深入了解LinkedHashMap>//localhost:1313/post/java-base/linkedhashmap/</a></li><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/algorithm/%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/ rel=next title=FIFO、LRU、LFU三种缓存淘汰算法><i class="fa fa-chevron-left"></i> FIFO、LRU、LFU三种缓存淘汰算法</a></div><div class="post-nav-prev post-nav-item"><a href=/post/java-concurrent/java%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/ rel=prev title=Java线程通信工具类的使用>Java线程通信工具类的使用
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>评论交流</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=waline-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2021 - 2024
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>shuyou</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.126.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.5.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script><script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":"trueMuse","giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"//localhost:1313/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline"},"views":{"enable":true,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.5.3","waline":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o \n\n可用快捷键选取表情符号：😀😄😁🥳👻👽👀🚄\n(Window系统：Win+.，Mac系统：Control+Command+Space)","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":"https://walinejs.comment.lithub.cc","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.js defer></script></body></html>