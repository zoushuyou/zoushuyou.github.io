---
title:      "深入了解JVM内存结构"
date:       2021-03-24
author: "shuyou"
categories: ["Code"]
tags:
    - JVM
---

>本文主要介绍JVM内存结构相关知识，需要注意JVM内存结构和Java内存模型是两个概念。

### 运行时数据区
Java虚拟机在执行程序时会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则依赖用户线程的启动和结束而建立和销毁。

下图是 JVM 整体架构，中间部分就是 Java 虚拟机定义的各种运行时数据区域。
在这里插入图片描述
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210324150056997.jpg?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhcnJvdFpzeQ==,size_16,color_FFFFFF,t_70#pic_center)
>下面介绍下这些内存结构

### 程序计数器
程序计数器（program counter  register）是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指令器。

 - 在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期一致。
 - 在任何一个时刻，一个处理器都只会处理一条线程中的指令，因此为了线程切换后能恢复到正确的执行位置，每条线程都要有一个独立的程序计数器，各条线程之间的计数器互不影响，我们称这类区域为“线程私有”区域。
 - 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成
 - 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
 - 它是唯一一个在 JVM 规范中没有规定任何 OutOfMemoryError 情况的区域

### 虚拟机栈
与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。

**Java虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行时，Java虚拟机都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。**

**栈不存在垃圾回收的问题**：进栈和出栈，出栈相当于释放内存。

栈中可能出现的异常：

 - 如果采用固定大小的 Java 虚拟机栈，那每个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个 StackOverflowError 异常
 - 如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个OutOfMemoryError异常

可以通过参数-Xss来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。

**栈帧是虚拟机栈的最小单位**：在用idea进行debug时，看到的就是一个个栈帧。

**栈帧的内部结构**：

- 局部变量表：主要用于存储方法参数和定义在方法体内的局部变量
- 操作数栈：主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间
- 动态链接：指向运行时常量池的方法引用
- 方法返回地址：方法正常退出或异常退出的地址
- 一些附加信息

### 本地方法栈
本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则是为虚拟机使用到的本地方法服务。

本地方法栈也是线程私有的。

>**栈是运行时的单位，而堆是存储的单位。**
>
>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪。

### 堆
对Java程序来说，Java堆是虚拟机所管理的内存中最大的一块。Java堆是被所有线程所共享的一块内存区域，在虚拟机启动时创建。

**此内存区域的唯一目的就是存放对象实例**

为了进行高效的垃圾回收，虚拟机把堆内存逻辑上划分成三块区域（分代的唯一理由就是优化 GC 性能）：

 - 新生代（年轻代）：新对象和没达到一定年龄的对象都在新生代
 - 老年代（养老区）：被长时间使用的对象，老年代的内存空间应该要比年轻代更大
 - 元空间（JDK1.8 之前叫永久代）：像一些方法中的操作临时对象等，JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存
![内存区域](https://img-blog.csdnimg.cn/20210324161121304.jpg#pic_center)
Java 虚拟机规范规定，Java 堆可以是处于物理上不连续的内存空间中，只要逻辑上是连续的即可，像磁盘空间一样。实现时，既可以是固定大小，也可以是可扩展的，主流虚拟机都是可扩展的（通过 -Xmx 和 -Xms 控制），如果堆中没有完成实例分配，并且堆无法再扩展时，就会抛出 OutOfMemoryError 异常。

**年轻代 (Young Generation)**

年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集。这种垃圾收集称为 Minor GC。年轻一代被分为三个部分——伊甸园（Eden Memory）和两个幸存区（Survivor Memory，被称为from/to或s0/s1），默认比例是8:1:1

 - 大多数新创建的对象都位于 Eden 内存空间中
 - 当 Eden 空间被对象填充时，执行Minor GC，并将所有幸存者对象移动到一个幸存者空间中
 - Minor GC 检查幸存者对象，并将它们移动到另一个幸存者空间。所以每次，总有一个幸存者空间是空的
 - 经过多次 GC 循环后存活下来的对象被移动到老年代。通常，这是通过设置年轻一代对象的年龄阈值来实现的，然后他们才有资格提升到老一代

**老年代(Old Generation)**

旧的一代内存包含那些经过许多轮小型 GC 后仍然存活的对象。通常，垃圾收集是在老年代内存满时执行的。老年代垃圾收集称为 主GC（Major GC），通常需要更长的时间。

大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden 区和两个Survivor 区之间发生大量的内存拷贝 

### 方法区
方法区与堆一样是被各个线程所共享的区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。

运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本/字段/方法/接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将类在加载后进入方法区的运行时常量池中存放。运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是 String.intern()方法。受方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。

除了和Java堆一样不需要连续的内存和可以选择内存大小或者可扩展外，方法区还可以选择不进行垃圾收集。这区域内存的回收目标主要是常量池的回收和对类型的卸载。

**方法区（method area）只是 JVM 规范中定义的一个概念，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。而永久代（PermGen）是 Hotspot 虚拟机特有的概念， Java8 的时候又被元空间取代了，永久代和元空间都可以理解为方法区的落地实现。**

永久代物理是堆的一部分，和新生代，老年代地址是连续的（受垃圾回收器管理），而元空间存在于本地内存（我们常说的堆外内存，不受垃圾回收器管理），这样就不受 JVM 限制了，也比较难发生OOM（都会有溢出异常）

所以对于方法区，Java8 之后的变化：

 - 移除了永久代（PermGen），替换为元空间（Metaspace）；
 - 永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；
 - 永久代参数 （PermSize MaxPermSize） -> 元空间参数（MetaspaceSize MaxMetaspaceSize）

**栈、堆、方法区的交互关系**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210324165854810.png?x-oss-process=image,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhcnJvdFpzeQ==,size_16,color_FFFFFF,t_70#pic_center)

**参考**

 1. 深入理解Java虚拟机
 2. [JVM 基础 - JVM 内存结构](https://www.pdai.tech/md/java/jvm/java-jvm-struct.html)
